# Step 11 Report

###### 刘泓尊　2018011446　计84

## 实验目的

	1.  增加对指针的支持
 	2.  引入左值，引入取地址运算符`&`和解引用运算符`*`
 	3.  支持类型转换

## 实验过程

  1. #### 实现左值分析

     左值的本质是有地址的值．为了支持左值检查，只需要在`unary '=' expr`和`& unary `两处进行左值检查即可．为此，我引入了新的*Visitor*在AST的局部进行遍历，对于`unary '=' expr`和`& unary`的字节点，如果其子节点`unary`是`* val`或者局部或全局变量`variable`，说明这是一个左值，否则报错．同时记录该左值的地址(`IrGlobalAddr`和`IrFrameAddr`)，为后面IR生成做准备．

     对于类型检查，我引入了在名称检查之后的又一遍AST遍历．用以完成和表达式类型相关的一大类语义检查，以及计算表达式的类型信息，提供给后续阶段使用．

  2. #### 实现类型检查

     为了支持类型检查，我创建了`Type`类，并由它派生出`IntType`, `PointerType`，其中`PointerType`内部维护了其指向的变量基类型．

     此外我引入了规则检查模块`rule.py`. 该模块负责检查表达式的实际类型，即输入操作数的类型和操作符类型，进行类型检查并返回表达式的类型或报错．这些规则包括：

     	1.　加法 `+` 只能 `int` 加 `int`, 结果还是 `int`。
      	2.　if 的条件表达式类型必须是 `int`，没有操作结果。
      	3.　解引用操作 `*e` 要求操作数类型 `e` 是指针类型 `T*`，结果类型是 `T`
      	4.　取地址操作符 `&e` 对源操作数类型没有要求，结果类型是 `PointerType(源操作数类型)`
      	5.　类型转换（`cast`）对源操作数类型没有要求，结果类型就是转换的目标类型。
      	6.　函数调用的结果类型是函数的返回类型

     `TypeVisitor`负责遍历AST, 同时创建每个节点的类型．比如，对于`scalar`节点，构建`IntType`；对于`pointer`类型，构建`PointerType(tp)`．对于`cast`类型，返回`tp`对应的类型等．

     需要指出的是，左值检查实际上是在此遍遍历完成的，当遍历到`ComplexUnary`和`ComplexAssign`节点的时候进行左值检查．

     同时在`TypeInfo`中关联每一个节点和它的类型，为后面的IR生成做准备．

  3. #### 修改文法，支持指针类型，支持取地址运算符`&`和解引用运算符`*`，支持类型转换

     增加了指针类型和指针变量的声明

     ```
     tp
         : 'int'         # scalar
         | tp '*'        # pointer
         ;
     declaration
         : tp Identifier ('[' Integer ']')* ('=' expr)? ';'
         ;
     ```

     支持取地址运算符和解引用运算符

     ```
     unOperator: 
         '-' | '~' | '!' | '&' | '*'
         ;
     ```

     支持类型转换

     ```
     unary
         : postfix             # SingleUnary
         | unOperator unary    # ComplexUnary
         | '(' tp ')' unary    # Cast
         ;
     ```

  4. #### IR生成

     IR生成阶段不需要修改太多．

     首先是支持取地址和解引用操作. 对于取地址操作，需要获得左值检查阶段绑定的变量地址，并将对应的IR指令（实际上就是`IrGlobalAddr`和`IrFrameAddr`）压栈．对于解引用操作，只需要子表达式的IR加上一个`load`操作（将栈顶指向的地址的内容压栈）．

     此外，还需要在函数定义或声明的地方解析它的返回值，以检查函数名和参数相同但返回值不同的错误．

  5. #### IR指令没有增加，不需要修改汇编生成代码

## 思考题

1. #### 为什么类型检查要放到名称解析之后？

   名称解析创建了保存变量的结构，并为每一个变量绑定了地址．一方面，类型检查中的左值检查需要获得它们的地址，所以必须为变量绑定地址．另一方面，类型检查会为＂变量＂(全局变量或局部变量)绑定＂类型＂，如果事先没有维护这些变量，那么就无法为其绑定类型，也就无法进行类型构造和检查了．

2. #### MiniDecaf 中一个值只能有一种类型，但在很多语言中并非如此，请举出一个反例。

   MiniDecaf 中一个值只能有一种类型保证了可以为其分配正确的栈空间，如果类型不定，那么栈空间无法确定．

   但实际上Ｃ语言就有`union`来实现一个值的多种类型，但是在分配栈空间时是以最大size的类型分配的,　多个类型共用一个地址．

   ```C
   union test　{
        char mark;
        long num;
        float score;
   };
   ```

   `TypeScript`也有类似的特性

   ```typescript
   type keyType = string | number;
   const strKey: keyType = 'key';
   const numKey: keyType = 1;
   ```

3. #### 在本次实验中我们禁止进行指针的比大小运算。请问如果要实现指针大小比较需要注意什么问题？可以和原来整数比较的方法一样吗？

   指针比较大小可以对其值比较大小,　即把地址当作数字去比较．

   需要注意的是，参与比较大小的指针类型应该相同，或者至少在不同时应该给出警告．

   比如下面的Ｃ代码会**警告**：`comparison of distinct pointer types lacks a cast`

   ```C
   int main() {
       int a = 1;
       int *p = &a;
       int **q = &p;
       return (p < q);
   }
   ```

   此外，对于没有初始化的野指针，其值是未定义行为，也可以给出警告，但使用时应注意．

   如果类型无误，比较大小和整数比较大小需要的汇编指令是一样的．比如对于指针`int* p`, `int *q`来说，先将两个指针的值（也就是对应变量的地址）加载到寄存器，然后使用汇编指令如`sltu`等比较大小即可．

## Honor Code

​	本节需要引入新的AST遍历阶段，需要引入的功能较多．其中左值检查部分参考了样例代码，构造了左值检查Visitor．