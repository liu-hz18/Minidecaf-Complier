# Step 7 Report

###### 刘泓尊　2018011446　计84

## 实验目的

　1.　增加块语句，利用变量栈实现作用域功能，配合之前实现的名称解析框架

## 实验过程

 1. #### 修改文法，增加块语句

    ```
    func
        : tp Identifier '(' ')' block   # funcDefine
        | tp Identifier '(' ')' ';'     # funcDeclare
        ;
    // block　实际上是step6添加的
    block
        : '{' blockitem* '}'
        ;
    ```

 2. #### 完善名称解析，增加语义检查

    名称解析的阶段任务就是把 **AST 中出现的每个变量名关联到对应的变量**，实现为一个遍历`AST`的`Visitor`.

    为了支持作用域与变量挂钩，需要将符号表修改为栈结构，栈中每个元素包含该作用域中声明过的所有变量．每次进入作用域就压栈，离开作用域弹栈．遇到变量调用的时候，从栈顶向下查找变量名，以实现内层声明覆盖外层声明．每次遇到声明时，确定栈上偏移，并将变量插入符号表即可．

    我的实现中的栈维护了一个积累栈和当前栈，每次进入新的作用域的时候，将父作用域的变量栈压入积累栈，然后当前栈清空．在子作用域声明新的变量时，向积累栈和当前栈都压入对应的变量即可．离开变量栈时，从两个栈中都`pop`对应的变量即可．同时需要进行重定义和未定义检查．

	3.　#### 因为没有增加IR语句，所以不需要修改汇编生成阶段

## 思考题

1. #### 请将下述 MiniDecaf 代码中的 `???` 替换为一个 32 位整数，使得程序运行结束后会返回 0。

   ```c++
   int main() {
    int x = 0;
    if (x) {
        return x;
    } else {
        int x = 2;
    }
    return x;
   }
   ```

   当`x = 0`时，`if(x)`中的表达式为`0`，所以会进入`else`块，`else`块中声明了`x`, 但是在离开`else`作用域后，`x`的值依然为`0`，最终返回`0`．

2. #### 在实验指导中，我们提到“就 MiniDecaf 而言，名称解析的代码也可以嵌入 IR 生成里”，但不是对于所有语言都可以把名称解析嵌入代码生成。试问被编译的语言有什么特征时，名称解析作为单独的一个阶段在 IR 生成之前执行会更好？

   名称解析保证了所使用的变量名绑定到了其声明位置．Ｃ语言要求函数或变量的声明要放在其调用的前面，但不是所有语言都是这样，这时就要先进行名称解析，甚至要多遍名称解析；如果直接进入代码生成，只遍历一遍AST，那么必须保证声明或定义在调用之前，不然就会编译错误．

   比如对于`java`而言，下面的代码是合法的

   ```java
   public class HelloWorld {
       public static void main(String []args) {
          System.out.println(a);
       }
   	static int a = 10; // declaration after using
   }
   ```

   对于类似这样的语言，就需要先进行名称解析，或者需要多遍遍历AST．

## Honor Code

​		参考了样例代码＂维护了一个积累栈和当前栈＂的做法，比实验指导书中介绍的＂维护一个栈，使用时自顶向下遍历变量栈＂更加方便，在大部分情况下也节约了编译时间．